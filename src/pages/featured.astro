---
import MainLayout from '../layouts/MainLayout.astro';
import HeroImageShader from '../components/HeroImageShader';

// Get page name from the URL path
const pageName = Astro.url.pathname
  .split('/')
  .filter(Boolean)
  .pop() || 'Home';
const pageTitle = pageName.charAt(0).toUpperCase() + pageName.slice(1);

// Page metadata
const pageDescription = "A collection of conference talks, podcasts, and interviews. Speaking engagements at Config, Hatch Conference, UX Cambridge, and more.";
const ogImage = "/images/highlights/img-highlights-hatch-conference.jpg";
---

<MainLayout title="Featured" description={pageDescription} ogImage={ogImage}>
  <div class="hero-image-container portrait-container">
    <HeroImageShader client:load src="/images/header-images/img-highlights-featured.jpg" alt="Featured speaking and media" />
    <h1>{pageTitle}</h1>
  </div>
  <div class="container">
    <div class="featured-grid">
      <div class="featured-item">
        <div class="featured-content">
          <h2>Speaking</h2>
            <h3>2025</h3>
            <ul>
              <li>May - <a href="https://nycxdesign.org/nycxdesign-talk-with-will-hall-designing-intelligence/" target="_blank">NYCxDESIGN: The future of software design</a></li>
              <li>May - <a href="https://www.youtube.com/watch?v=xkriqGkodQA" target="_blank">Config 2025: Maturing your teams & your leadership</a></li>
            </ul>
            <h3>2024</h3>
            <ul>
              <li>September - <a href="https://www.youtube.com/watch?v=4lWYcr53kyI" target="_blank">Hatch Conference: Design and (Blank)</a></li>
            </ul>
            <h3>2022</h3>
            <ul>
            <li>October - Disco Conf by Maze: Prototyping towards outcomes</li>
            <li>November - Front Utah: Leading and operating design orgs</li>
            </ul>

            <h3>2021</h3>
            <ul>
            <li>April - <a href="https://www.youtube.com/watch?app=desktop&v=piGC-iFwmrk&t=45s" target="_blank">Figma Config: The Universal Challenges of Every Scaling Design Team</a></li>
            <li>March - Design Career Network - From Designer to Manager</li>
            <li>January - Product Hive: Lessons Learned in Prototyping</li>
            </ul>

            <h3>2020</h3>
            <ul>
            <li>December - Curiousity: The Product Development Superpower (Duke University)</li>
            <li>November - Principles and Allegories (Hyper Island)</li>
            </ul>

            <h3>2019</h3>
            <ul>
            <li>November - No Code Conference</li>
            <li>November - Productized in Lisbon, Portugal</li>
            <li>April - Designing for healthcare</li>
            </ul>

            <h3>2018</h3>
            <ul>
            <li>October - UXDX in Dublin, Ireland</li>
            <li>September - UX Cambridge in Cambridge, UK – An introduction to human-centred design leadership</li>
            <li>June - UX Scotland in Edinburgh, Scotland – Play the part: an introduction to technology experience prototyping</li>
            <li>June - UX Scotland in Edinburgh, Scotland – Human-Centered Design Leadership</li>
            <li>March - try!Swift, Tokyo, Japan</li>
            <li>February - Seattle Xcoders in Seattle, Washington</li>
            </ul>

            <h3>2017</h3>
            <ul>
            <li>September - UX Cambridge</li>
            <li>September - SwiftConf in Cologne, Germany</li>
            <li>June - Cocoa Conf Next Door in San Jose, California</li>
            <li>March - Design for Healthcare: Designing For Doctors</li>
            <li>March - Seattle Xcoders: Build Like a Kid</li>
            </ul>

            <h3>2016</h3>
            <ul>
            <li>September 29 - VanCocoa</li>
            <li>September 14-16 - UX Cambridge</li>
            <li>September 9-10 - CocoaConf Washington DC</li>
            <li>May 6-7 - CocoaConf in Seattle, WA</li>
            <li>April 14 - Seattle Xcoders: Me too! Designers working in Xcode</li>
            <li>April 6 - Tradecraft: Fast With Intent—Learning Through Rapid Prototyping</li>
            </ul>

            <h3>2015</h3>
            <ul>
            <li>July 15 - Seattle Prototyping for Designers</li>
            <li>May 8-9 - CocoaConf 2015 in Portland, Oregon: Designing For WATCH</li>
            <li>January 8 - Seattle Xcoders in Seattle, Washington: Designing for WATCH before it ships</li>
            </ul>

            <h3>2013</h3>
            <ul>
            <li>Seattle Ignite: Coast-To-Coast: How to live in two cities</li>
            </ul>
        </div>
      </div>

      <div class="featured-item">
        <div class="featured-content">
          <h2>Media and publications</h2>
          <ul>
            <li><a href="https://www.codenewbie.org/podcast/how-no-code-tools-can-help-your-coding" target="_blank">Code Newbie: How no-code tools can help your coding</a></li>
            <li><a href="https://webflow.com/blog/from-no-code-to-know-code" target="_blank">From no-code to know code</a></li>
          </ul>
        </div>
      </div>
    </div>
  </div>
  </div>  
</MainLayout>

<style>

  .featured-content-intro {
    max-width: 800px;
    width: 100%;
  }


  .featured-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 0rem;
    margin: 1rem 0rem;
  }

  .featured-item {
    overflow: hidden;
  }

  .featured-content {
    
  }

  .read-more {
    display: inline-block;
    margin-top: 1rem;
    color: var(--primary-color);
    text-decoration: none;
  }

  .read-more:hover {
    text-decoration: underline;
  }

  @media (max-width: 768px) {
    .featured-content-intro {
      max-width: 100%;
    }
  }

  @media (max-width: 480px) {
    .featured-content-intro {
      max-width: 100%;
    }
  }
</style>

<script>
  // Parallax scroll effect with smooth inertia-based animation
  function initParallax() {
    const imageContainer = document.querySelector('.hero-image-container') as HTMLElement | null;
    const image = document.querySelector('.hero-image-bg') as HTMLElement | null;

    if (!imageContainer || !image) return;

    let currentOffset = 0;
    let targetOffset = 0;
    let currentScale = 1;
    let targetScale = 1;
    let velocity = 0;
    let lastScrollY = window.scrollY;
    let lastTime = performance.now();
    let animationFrameId: number | null = null;
    let isScrolling = false;
    let scrollTimeout: number | null = null;

    // Smooth interpolation with inertia
    function lerp(start: number, end: number, factor: number) {
      return start + (end - start) * factor;
    }

    function calculateParallaxValues() {
      if (!imageContainer) return { offset: 0, scale: 1 };

      const rect = imageContainer.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      const containerHeight = imageContainer.offsetHeight;
      const scrolled = window.scrollY;
      const containerTop = imageContainer.offsetTop;
      
      if (rect.bottom >= 0 && rect.top <= windowHeight) {
        const scrollDistance = scrolled - containerTop;
        const parallaxSpeed = 0.3;
        const offset = scrollDistance * parallaxSpeed;
        
        // Calculate scroll progress (0 to 1) within the container viewport
        // Scale from 1 to 1.2 as user scrolls down
        const scrollProgress = Math.max(0, Math.min(1, 
          (scrollDistance + windowHeight) / (containerHeight + windowHeight)
        ));
        const scale = 1 + (scrollProgress * 0.5); // 1 to 1.5
        
        return { offset, scale };
      } else if (rect.top > windowHeight) {
        return { offset: 0, scale: 1 };
      }
      return { offset: currentOffset, scale: currentScale };
    }

    function animate() {
      const now = performance.now();
      const deltaTime = Math.min((now - lastTime) / 1000, 0.1); // Cap at 100ms
      lastTime = now;

      // Calculate target offset and scale
      const { offset, scale } = calculateParallaxValues();
      targetOffset = offset;
      targetScale = scale;

      // Smooth interpolation with momentum
      const lerpFactor = isScrolling ? 0.15 : 0.08; // Faster when scrolling, slower when settling
      currentOffset = lerp(currentOffset, targetOffset, lerpFactor);
      currentScale = lerp(currentScale, targetScale, lerpFactor);

      // Apply velocity for inertia effect
      if (!isScrolling) {
        const difference = targetOffset - currentOffset;
        velocity = lerp(velocity, difference * 0.5, 0.1);
        currentOffset += velocity;
        
        // Damping - gradually reduce velocity
        velocity *= 0.92;
        
        // Stop animation when very close to target
        if (Math.abs(targetOffset - currentOffset) < 0.1 && Math.abs(velocity) < 0.1) {
          currentOffset = targetOffset;
          currentScale = targetScale;
          velocity = 0;
        }
      }

      // Apply transform with both translateY and scale
      if (image) {
        image.style.transform = `translateY(${currentOffset}px) scale(${currentScale})`;
      }

      // Continue animation if needed
      if (isScrolling || Math.abs(targetOffset - currentOffset) > 0.1 || Math.abs(targetScale - currentScale) > 0.001 || Math.abs(velocity) > 0.1) {
        animationFrameId = requestAnimationFrame(animate);
      } else {
        animationFrameId = null;
      }
    }

    function onScroll() {
      const currentScrollY = window.scrollY;
      const scrollDelta = currentScrollY - lastScrollY;
      lastScrollY = currentScrollY;

      // Mark as scrolling
      isScrolling = true;
      
      // Clear existing timeout
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }

      // Start animation if not already running
      if (!animationFrameId) {
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(animate);
      }

      // Detect when scrolling stops
      scrollTimeout = setTimeout(() => {
        isScrolling = false;
        // Continue animation for smooth deceleration
        if (!animationFrameId) {
          lastTime = performance.now();
          animationFrameId = requestAnimationFrame(animate);
        }
      }, 50) as unknown as number;
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    
    // Initial setup
    const initialValues = calculateParallaxValues();
    targetOffset = initialValues.offset;
    currentOffset = targetOffset;
    targetScale = initialValues.scale;
    currentScale = targetScale;
    lastTime = performance.now();
    animate();
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initParallax);
  } else {
    initParallax();
  }
</script> 