---
import MainLayout from '../layouts/MainLayout.astro';
import SubstackSignup from '../components/SubstackSignup.astro';
import imgProofOfConcept from '../assets/images/highlights/img-highlights-proof-of-concept.jpg';
import imgLinen from '../assets/images/bg-linen.jpeg';

// Get page name from the URL path
const pageName = Astro.url.pathname
  .split('/')
  .filter(Boolean)
  .pop() || 'Home';
const pageTitle = pageName.charAt(0).toUpperCase() + pageName.slice(1);

// Page metadata
const pageDescription = "Subscribe to Proof of Concept, a digital newsletter publication that explores experimentation and maximizing your creative output. Free issue every Sunday.";
const ogImage = "/images/highlights/img-highlights-proof-of-concept.jpg";
---

<MainLayout title="Subscribe" description={pageDescription} ogImage={ogImage}>
  <div class="container">
    <div class="subscribe-image-container">
      <div class="linen-background" style={`background-image: url(${imgLinen.src})`}></div>
      <img class="subscribe-image" src={imgProofOfConcept.src} alt="Proof of Concept" />
      <div class="image-overlay">
        <h1 class="overlay-text">{pageTitle}</h1>
      </div>
    </div>
    <div class="hero-grid">
      <div class="subscribe-content-intro">
        <p>Proof of Concept is digital newsletter publication that explores experimentation and maximizing your creative output. You'll receive a free issue every Sunday. I appreciate your readership!</p>
      </div>
    </div>
    <!-- Newsletter Section -->
    <section class="newsletter-section" aria-labelledby="newsletter-heading">
        <SubstackSignup 
          title="Subscribe to my newsletter"
          description="Get a free issue every Sunday about design, technology, and entrepreneurship."
        />
    </section>
  </div>
    
</MainLayout>

<style>
  .hero-grid {
    display: flex;
    justify-content: center;
    margin: 2rem 0;
  }

  .subscribe-content-intro {
    max-width: 800px;
    width: 100%;
  }

  .subscribe-image-container {
    width: 100vw;
    max-width: 100vw;
    aspect-ratio: 16 / 9;
    margin-top: calc(0px - clamp(1rem, 3vw, 2rem));
    margin-bottom: 2rem;
    margin-left: calc(50% - 50vw - clamp(1rem, 3vw, 2rem));
    margin-right: calc(50% - 50vw - clamp(1rem, 3vw, 2rem));
    overflow: hidden;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .linen-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    opacity: 0;
    transform: translateY(-100%);
    transition: opacity 0.3s ease, transform 0.3s ease;
    z-index: 0;
  }

  .subscribe-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center top;
    display: block;
    flex-shrink: 0;
    will-change: transform;
    position: relative;
    z-index: 1;
  }

  .image-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.3);
    z-index: 1;
  }

  .overlay-text {
    color: white;
    font-size: clamp(3rem, 8vw, 8rem);
    font-weight: 700;
    text-align: center;
    margin: 0;
    text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
    letter-spacing: -0.02em;
  }

  .subscribe-wrapper {
    max-width: 600px;
    margin: 0 auto;
    padding: 2rem;
  }

  .subscribe-content {
    background: #fff;
    padding: 2rem;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .subscribe-form {
    margin-top: 2rem;
  }

  .form-group {
    margin-bottom: 1.5rem;
  }

  label {
    display: block;
    margin-bottom: 0.5rem;
    color: var(--primary-color);
  }

  input[type="text"],
  input[type="email"] {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-size: 1rem;
  }

  .subscribe-button {
    background: var(--primary-color);
    color: white;
    border: none;
    padding: 0.75rem 1.5rem;
    border-radius: 6px;
    font-size: 1rem;
    cursor: pointer;
    width: 100%;
  }

  .subscribe-button:hover {
    opacity: 0.9;
  }

  @media (max-width: 768px) {
    .subscribe-image-container {
      aspect-ratio: 3 / 4;
    }

    .hero-grid {
      padding: 0 1rem;
    }

    .subscribe-content-intro {
      max-width: 100%;
    }
  }

  @media (max-width: 480px) {
    .hero-grid {
      padding: 0 0.5rem;
      margin: 1rem 0;
    }

    .subscribe-content-intro {
      max-width: 100%;
    }
  }
</style>

<script>
  // Parallax scroll effect with smooth inertia-based animation
  function initParallax() {
    const imageContainer = document.querySelector('.subscribe-image-container') as HTMLElement | null;
    const image = document.querySelector('.subscribe-image') as HTMLElement | null;
    const linenBackground = document.querySelector('.linen-background') as HTMLElement | null;

    if (!imageContainer || !image) return;

    let currentOffset = 0;
    let targetOffset = 0;
    let currentScale = 1;
    let targetScale = 1;
    let velocity = 0;
    let lastScrollY = window.scrollY;
    let lastTime = performance.now();
    let animationFrameId: number | null = null;
    let isScrolling = false;
    let scrollTimeout: number | null = null;
    let overscrollAmount = 0;
    let currentOverscroll = 0;
    let touchStartY = 0;
    let isPulling = false;

    // Smooth interpolation with inertia
    function lerp(start: number, end: number, factor: number) {
      return start + (end - start) * factor;
    }

    function calculateParallaxValues() {
      if (!imageContainer) return { offset: 0, scale: 1 };

      const rect = imageContainer.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      const containerHeight = imageContainer.offsetHeight;
      const scrolled = window.scrollY;
      const containerTop = imageContainer.offsetTop;
      
      // If not actively pulling, reset overscroll
      if (!isPulling) {
        overscrollAmount = Math.max(0, overscrollAmount * 0.92); // Damping
      }
      
      if (rect.bottom >= 0 && rect.top <= windowHeight) {
        const scrollDistance = scrolled - containerTop;
        const parallaxSpeed = 0.3;
        const offset = scrollDistance * parallaxSpeed;
        
        // Calculate scroll progress (0 to 1) within the container viewport
        // Scale from 1 to 1.2 as user scrolls down
        const scrollProgress = Math.max(0, Math.min(1, 
          (scrollDistance + windowHeight) / (containerHeight + windowHeight)
        ));
        const scale = 1 + (scrollProgress * 0.5); // 1 to 1.5
        
        return { offset, scale };
      } else if (rect.top > windowHeight) {
        return { offset: 0, scale: 1 };
      }
      return { offset: currentOffset, scale: currentScale };
    }

    function animate() {
      const now = performance.now();
      const deltaTime = Math.min((now - lastTime) / 1000, 0.1); // Cap at 100ms
      lastTime = now;

      // Calculate target offset and scale
      const { offset, scale } = calculateParallaxValues();
      targetOffset = offset;
      targetScale = scale;

      // Smooth interpolation with momentum
      const lerpFactor = isScrolling ? 0.15 : 0.08; // Faster when scrolling, slower when settling
      currentOffset = lerp(currentOffset, targetOffset, lerpFactor);
      currentScale = lerp(currentScale, targetScale, lerpFactor);

      // Apply velocity for inertia effect
      if (!isScrolling) {
        const difference = targetOffset - currentOffset;
        velocity = lerp(velocity, difference * 0.5, 0.1);
        currentOffset += velocity;
        
        // Damping - gradually reduce velocity
        velocity *= 0.92;
        
        // Stop animation when very close to target
        if (Math.abs(targetOffset - currentOffset) < 0.1 && Math.abs(velocity) < 0.1) {
          currentOffset = targetOffset;
          currentScale = targetScale;
          velocity = 0;
        }
      }

      // Smooth overscroll interpolation
      currentOverscroll = lerp(currentOverscroll, overscrollAmount, 0.15);

      // Apply transform with both translateY and scale
      if (image) {
        image.style.transform = `translateY(${currentOffset}px) scale(${currentScale})`;
      }

      // Reveal linen background based on overscroll
      if (linenBackground) {
        const maxOverscroll = 200; // Maximum pull distance
        const overscrollProgress = Math.min(currentOverscroll / maxOverscroll, 1);
        const translateY = -100 + (overscrollProgress * 100); // Reveal from top

        linenBackground.style.opacity = String(overscrollProgress);
        linenBackground.style.transform = `translateY(${translateY}%)`;
      }

      // Continue animation if needed
      if (isScrolling || Math.abs(targetOffset - currentOffset) > 0.1 || Math.abs(targetScale - currentScale) > 0.001 || Math.abs(velocity) > 0.1 || currentOverscroll > 0.1) {
        animationFrameId = requestAnimationFrame(animate);
      } else {
        animationFrameId = null;
      }
    }

    function onScroll() {
      const currentScrollY = window.scrollY;
      const scrollDelta = currentScrollY - lastScrollY;
      lastScrollY = currentScrollY;

      // Mark as scrolling
      isScrolling = true;
      
      // Clear existing timeout
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }

      // Start animation if not already running
      if (!animationFrameId) {
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(animate);
      }

      // Detect when scrolling stops
      scrollTimeout = setTimeout(() => {
        isScrolling = false;
        // Continue animation for smooth deceleration
        if (!animationFrameId) {
          lastTime = performance.now();
          animationFrameId = requestAnimationFrame(animate);
        }
      }, 50) as unknown as number;
    }

    // Touch events for pull-to-reveal
    function onTouchStart(e: TouchEvent) {
      if (window.scrollY <= 0 && imageContainer && imageContainer.getBoundingClientRect().top <= 0) {
        touchStartY = e.touches[0].clientY;
        isPulling = true;
      }
    }

    function onTouchMove(e: TouchEvent) {
      if (!isPulling) return;

      const currentY = e.touches[0].clientY;
      const deltaY = currentY - touchStartY;
      
      if (deltaY > 0 && window.scrollY <= 0) {
        // Pulling down at the top
        overscrollAmount = deltaY;
        e.preventDefault(); // Prevent default scroll
      } else {
        isPulling = false;
        overscrollAmount = 0;
      }
    }

    function onTouchEnd() {
      isPulling = false;
    }

    // Wheel events for desktop pull-to-reveal
    function onWheel(e: WheelEvent) {
      if (window.scrollY <= 0 && imageContainer && imageContainer.getBoundingClientRect().top <= 0) {
        if (e.deltaY < 0) {
          // Scrolling up at the top (pulling down)
          isPulling = true;
          overscrollAmount = Math.min(overscrollAmount + Math.abs(e.deltaY), 300);
          e.preventDefault();
        } else {
          isPulling = false;
        }
      } else {
        isPulling = false;
      }
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('touchstart', onTouchStart, { passive: true });
    window.addEventListener('touchmove', onTouchMove, { passive: false });
    window.addEventListener('touchend', onTouchEnd, { passive: true });
    window.addEventListener('wheel', onWheel, { passive: false });
    
    // Initial setup
    const initialValues = calculateParallaxValues();
    targetOffset = initialValues.offset;
    currentOffset = targetOffset;
    targetScale = initialValues.scale;
    currentScale = targetScale;
    lastTime = performance.now();
    animate();
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initParallax);
  } else {
    initParallax();
  }
</script> 