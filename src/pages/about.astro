---
import MainLayout from '../layouts/MainLayout.astro';
import imgDavidSf from '../assets/images/img-david-sf.jpg';
import imgLinen from '../assets/images/bg-linen.jpeg';

// Get page name from the URL path
const pageName = Astro.url.pathname
  .split('/')
  .filter(Boolean)
  .pop() || 'Home';
const pageTitle = pageName.charAt(0).toUpperCase() + pageName.slice(1);

// Page metadata
const pageDescription = "I'm a designer, investor, and builder focused on tools that revolutionize the internet. VP and Head of Design, AI at Atlassian. Previously at Replit, Webflow, and One Medical.";
const ogImage = "/images/img-david-sf.jpg";
---

<MainLayout title="About" description={pageDescription} ogImage={ogImage}>
  <div class="container">
    <div class="about-image-container">
      <div class="linen-background" style={`background-image: url(${imgLinen.src})`}></div>
      <img class="about-image" src={imgDavidSf.src} alt="David Hoang in San Francisco" />
      <div class="image-overlay">
        <h1 class="overlay-text">{pageTitle}</h1>
      </div>
    </div>
    <div class="hero-grid">
      <div class="about-content">
        <p>I'm a designer, investor, and builder focused on tools that revolutionize the internet. My career has been an <a href="/career-odyssey">odyssey</a>—20 years in and still so much to learn and experience. My love for design and software began after graduating with a BFA in Drawing and Painting. Interdisciplinary studies led me to electives in Computer Science, Art History, and the Humanities. After matriculation, I took what's now called a gap year to prepare for an MFA; I never went, instead designing app interfaces for a new device called the iPhone.</p>
        <p>Since then, I've spent my career building and scaling design teams at early-stage startups and high-growth companies. I currently serve as VP of Design, Rovo & AI at <a href="http://atlassian.com" target="_blank">Atlassian</a>, building AI experiences that will use Jira for me so I never have to. Prior, I was VP of Marketing and Design at <a href="http://replit.com" target="_blank">Replit</a>, where I led rebranding, launched developer events, and pushed forward new ways to ship AI-native products. I was also the first Head of Design at <a href="http://webflow.com" target="_blank">Webflow</a>, where I helped scale both the team and the company's vision for a more expressive, accessible internet. Prior to that, I led product design at <a href="http://onemedical.com" target="_blank">One Medical</a> during its transition to virtual care and eventual IPO.</p>
        <p>I invest in and advise early-stage startups, especially creative tools that empower people to express on the internet. I've invested in over 30 early-stage companies: <a href="https://sunflower.me/" target="_blank">Sunflower</a>, <a href="https://www.withdaydream.com/" target="_blank">Daydream</a>, <a href="https://explore.ozu.ai/" target="_blank">OZU</a>, <a href="https://stitch.withgoogle.com/" target="_blank">Galileo (aquired)</a>, <a href="https://www.tryflint.com/" target="_blank">Flint</a>, and <a href="https://paper.design/" target="_blank">Paper</a>, to name a few . I also write a weekly newsletter called <a href="http://www.proofofconcept.pub">Proof of Concept</a>, where I explore ideas around software, design, and entrepreneurship. It's a space for me to reflect on the shifting landscape of technology and how we build within it.</p>
        <p>I'm particularly interested in how AI is reshaping software architecture and the way we build. I explore ideas like <a href="/writing/a-new-mvc-is-emerging">the emerging MVC</a>—where LLMs become models, apps become views, and agents become controllers—and how we're moving from app-centric to system-centric experiences. I think deeply about <a href="/writing/design-engineering">design engineering</a> as the transformative practice of the 2020s, the intersection of technical systems and interface quality. I'm fascinated by <a href="/writing/the-four-types-of-software-in-the-future">the future of software</a>—from boutique experiences to personal and disposable software—and how the lowering barriers to creation are democratizing who can build. I also reflect on the role of craft and taste in design, how tech goes through factory reset moments, and what it means to build creative tools that empower expression on the internet.</p>
        <p>See what I'm up to <a href="/now">now</a>.</p>
      </div>
    </div>
  </div>
</MainLayout>

<style>
  .hero-grid {
    display: flex;
    justify-content: center;
    margin: 2rem 0;
  }

  .about-content {
    max-width: 800px;
    width: 100%;
  }

  .about-image-container {
    width: 100vw;
    max-width: 100vw;
    aspect-ratio: 16 / 9;
    margin-top: calc(0px - clamp(1rem, 3vw, 2rem));
    margin-bottom: 2rem;
    margin-left: calc(50% - 50vw - clamp(1rem, 3vw, 2rem));
    margin-right: calc(50% - 50vw - clamp(1rem, 3vw, 2rem));
    overflow: hidden;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .linen-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    opacity: 0;
    transform: translateY(-100%);
    transition: opacity 0.3s ease, transform 0.3s ease;
    z-index: 0;
  }

  .about-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center top;
    display: block;
    flex-shrink: 0;
    will-change: transform;
    position: relative;
    z-index: 1;
  }

  .image-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.3);
    z-index: 1;
  }

  .overlay-text {
    color: white;
    font-size: clamp(3rem, 8vw, 8rem);
    font-weight: 700;
    text-align: center;
    margin: 0;
    text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);
    letter-spacing: -0.02em;
  }
  
  /* Ensure other images in content stay in container */
  .about-content img:not(.about-image) {
    max-width: 100%;
    height: auto;
  }

  @media (max-width: 768px) {
    .about-image-container {
      aspect-ratio: 3 / 4;
    }

    .hero-grid {
      padding: 0 1rem;
    }

    .about-content {
      max-width: 100%;
    }
  }

  @media (max-width: 480px) {
    .hero-grid {
      padding: 0 0.5rem;
      margin: 1rem 0;
    }

    .about-content {
      max-width: 100%;
    }
  }
</style>

<script>
  // Parallax scroll effect with smooth inertia-based animation
  function initParallax() {
    const imageContainer = document.querySelector('.about-image-container') as HTMLElement | null;
    const image = document.querySelector('.about-image') as HTMLElement | null;
    const linenBackground = document.querySelector('.linen-background') as HTMLElement | null;

    if (!imageContainer || !image) return;

    let currentOffset = 0;
    let targetOffset = 0;
    let currentScale = 1;
    let targetScale = 1;
    let velocity = 0;
    let lastScrollY = window.scrollY;
    let lastTime = performance.now();
    let animationFrameId: number | null = null;
    let isScrolling = false;
    let scrollTimeout: number | null = null;
    let overscrollAmount = 0;
    let currentOverscroll = 0;
    let touchStartY = 0;
    let isPulling = false;

    // Smooth interpolation with inertia
    function lerp(start: number, end: number, factor: number) {
      return start + (end - start) * factor;
    }

    function calculateParallaxValues() {
      if (!imageContainer) return { offset: 0, scale: 1 };

      const rect = imageContainer.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      const containerHeight = imageContainer.offsetHeight;
      const scrolled = window.scrollY;
      const containerTop = imageContainer.offsetTop;
      
      // Calculate overscroll (when at top and trying to scroll up)
      const isAtTop = scrolled <= 0;
      const isContainerVisible = rect.bottom >= 0 && rect.top <= windowHeight;
      
      // If not actively pulling, reset overscroll
      if (!isPulling) {
        overscrollAmount = Math.max(0, overscrollAmount * 0.92); // Damping
      }
      
      if (rect.bottom >= 0 && rect.top <= windowHeight) {
        const scrollDistance = scrolled - containerTop;
        const parallaxSpeed = 0.3;
        const offset = scrollDistance * parallaxSpeed;
        
        // Calculate scroll progress (0 to 1) within the container viewport
        // Scale from 1 to 1.2 as user scrolls down
        const scrollProgress = Math.max(0, Math.min(1, 
          (scrollDistance + windowHeight) / (containerHeight + windowHeight)
        ));
        const scale = 1 + (scrollProgress * 0.5); // 1 to 1.5
        
        return { offset, scale };
      } else if (rect.top > windowHeight) {
        return { offset: 0, scale: 1 };
      }
      return { offset: currentOffset, scale: currentScale };
    }

    function animate() {
      const now = performance.now();
      const deltaTime = Math.min((now - lastTime) / 1000, 0.1); // Cap at 100ms
      lastTime = now;

      // Calculate target offset and scale
      const { offset, scale } = calculateParallaxValues();
      targetOffset = offset;
      targetScale = scale;

      // Smooth interpolation with momentum
      const lerpFactor = isScrolling ? 0.15 : 0.08; // Faster when scrolling, slower when settling
      currentOffset = lerp(currentOffset, targetOffset, lerpFactor);
      currentScale = lerp(currentScale, targetScale, lerpFactor);

      // Apply velocity for inertia effect
      if (!isScrolling) {
        const difference = targetOffset - currentOffset;
        velocity = lerp(velocity, difference * 0.5, 0.1);
        currentOffset += velocity;
        
        // Damping - gradually reduce velocity
        velocity *= 0.92;
        
        // Stop animation when very close to target
        if (Math.abs(targetOffset - currentOffset) < 0.1 && Math.abs(velocity) < 0.1) {
          currentOffset = targetOffset;
          currentScale = targetScale;
          velocity = 0;
        }
      }

      // Smooth overscroll interpolation
      currentOverscroll = lerp(currentOverscroll, overscrollAmount, 0.15);

      // Apply transform with both translateY and scale
      if (image) {
        image.style.transform = `translateY(${currentOffset}px) scale(${currentScale})`;
      }

      // Reveal linen background based on overscroll
      if (linenBackground) {
        const maxOverscroll = 200; // Maximum pull distance
        const overscrollProgress = Math.min(currentOverscroll / maxOverscroll, 1);
        const translateY = -100 + (overscrollProgress * 100); // Reveal from top

        linenBackground.style.opacity = String(overscrollProgress);
        linenBackground.style.transform = `translateY(${translateY}%)`;
      }

      // Continue animation if needed
      if (isScrolling || Math.abs(targetOffset - currentOffset) > 0.1 || Math.abs(targetScale - currentScale) > 0.001 || Math.abs(velocity) > 0.1 || currentOverscroll > 0.1) {
        animationFrameId = requestAnimationFrame(animate);
      } else {
        animationFrameId = null;
      }
    }

    function onScroll() {
      const currentScrollY = window.scrollY;
      const scrollDelta = currentScrollY - lastScrollY;
      lastScrollY = currentScrollY;

      // Mark as scrolling
      isScrolling = true;
      
      // Clear existing timeout
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }

      // Start animation if not already running
      if (!animationFrameId) {
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(animate);
      }

      // Detect when scrolling stops
      scrollTimeout = setTimeout(() => {
        isScrolling = false;
        // Continue animation for smooth deceleration
        if (!animationFrameId) {
          lastTime = performance.now();
          animationFrameId = requestAnimationFrame(animate);
        }
      }, 50) as unknown as number;
    }

    // Touch events for pull-to-reveal
    function onTouchStart(e: TouchEvent) {
      if (window.scrollY <= 0 && imageContainer && imageContainer.getBoundingClientRect().top <= 0) {
        touchStartY = e.touches[0].clientY;
        isPulling = true;
      }
    }

    function onTouchMove(e: TouchEvent) {
      if (!isPulling) return;

      const currentY = e.touches[0].clientY;
      const deltaY = currentY - touchStartY;

      if (deltaY > 0 && window.scrollY <= 0) {
        // Pulling down at the top
        overscrollAmount = deltaY;
        e.preventDefault(); // Prevent default scroll
      } else {
        isPulling = false;
        overscrollAmount = 0;
      }
    }

    function onTouchEnd() {
      isPulling = false;
    }

    // Wheel events for desktop pull-to-reveal
    function onWheel(e: WheelEvent) {
      if (window.scrollY <= 0 && imageContainer && imageContainer.getBoundingClientRect().top <= 0) {
        if (e.deltaY < 0) {
          // Scrolling up at the top (pulling down)
          isPulling = true;
          overscrollAmount = Math.min(overscrollAmount + Math.abs(e.deltaY), 300);
          e.preventDefault();
        } else {
          isPulling = false;
        }
      } else {
        isPulling = false;
      }
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    window.addEventListener('touchstart', onTouchStart, { passive: true });
    window.addEventListener('touchmove', onTouchMove, { passive: false });
    window.addEventListener('touchend', onTouchEnd, { passive: true });
    window.addEventListener('wheel', onWheel, { passive: false });
    
    // Initial setup
    const initialValues = calculateParallaxValues();
    targetOffset = initialValues.offset;
    currentOffset = targetOffset;
    targetScale = initialValues.scale;
    currentScale = targetScale;
    lastTime = performance.now();
    animate();
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initParallax);
  } else {
    initParallax();
  }
</script>
