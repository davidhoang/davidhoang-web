---
import MainLayout from '../layouts/MainLayout.astro';
import HeroImageShader from '../components/HeroImageShader';
import { readFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Get page name from the URL path
const pageName = Astro.url.pathname
  .split('/')
  .filter(Boolean)
  .pop() || 'Home';
const pageTitle = pageName.charAt(0).toUpperCase() + pageName.slice(1);

// Page metadata
const pageDescription = "I'm a designer, investor, and builder focused on tools that revolutionize the internet. VP and Head of Design, AI at Atlassian. Previously at Replit, Webflow, and One Medical.";
const ogImage = "/images/img-david-sf.jpg";

// Simple markdown to HTML converter (handles links and paragraphs)
function markdownToHtml(markdown: string): string {
  let html = markdown.trim();
  
  // Convert markdown links [text](url) to HTML links
  // Add target="_blank" for external URLs
  html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
    const isExternal = url.startsWith('http://') || url.startsWith('https://');
    const target = isExternal ? ' target="_blank"' : '';
    return `<a href="${url}"${target}>${text}</a>`;
  });
  
  // Split into paragraphs (double newline or single newline followed by content)
  const paragraphs = html.split(/\n\n+/).filter(p => p.trim());
  
  // Wrap each paragraph in <p> tags
  return paragraphs.map(p => `<p>${p.trim()}</p>`).join('\n');
}

// Parse bio markdown file
async function parseBioMarkdown() {
  // Resolve path relative to project root (works in both dev and build)
  const currentFileUrl = import.meta.url;
  const currentFilePath = fileURLToPath(new URL('.', currentFileUrl));
  // Go up from dist/server/pages to project root
  const projectRoot = currentFilePath.includes('dist') 
    ? join(currentFilePath, '../../../')
    : join(currentFilePath, '../../');
  const bioPath = join(projectRoot, 'src/content/bio.md');
  const bioContent = await readFile(bioPath, 'utf-8');
  
  // Split by H2 headings (##)
  const lines = bioContent.split('\n');
  const bios: Array<{ title: string; content: string }> = [];
  let currentTitle = '';
  let currentContent: string[] = [];
  
  for (const line of lines) {
    // Check if this is an H2 heading
    if (line.startsWith('## ')) {
      // Save previous section if it exists
      if (currentTitle && currentContent.length > 0) {
        bios.push({
          title: currentTitle,
          content: markdownToHtml(currentContent.join('\n'))
        });
      }
      // Start new section
      currentTitle = line.substring(3).trim();
      currentContent = [];
    } else {
      // Add to current content
      currentContent.push(line);
    }
  }
  
  // Don't forget the last section
  if (currentTitle && currentContent.length > 0) {
    bios.push({
      title: currentTitle,
      content: markdownToHtml(currentContent.join('\n'))
    });
  }
  
  return bios;
}

// Load AI Summary if available
async function loadAISummary() {
  try {
    // Resolve path relative to project root (works in both dev and build)
    const currentFileUrl = import.meta.url;
    const currentFilePath = fileURLToPath(new URL('.', currentFileUrl));
    // Go up from dist/server/pages to project root
    const projectRoot = currentFilePath.includes('dist') 
      ? join(currentFilePath, '../../../')
      : join(currentFilePath, '../../');
    const aiSummaryPath = join(projectRoot, 'src/data/bio-ai-summary.json');
    const aiSummaryContent = await readFile(aiSummaryPath, 'utf-8');
    const aiSummary = JSON.parse(aiSummaryContent);
    
    if (aiSummary.content && aiSummary.content.trim()) {
      return {
        title: 'AI Summary',
        content: markdownToHtml(aiSummary.content),
        isAI: true
      };
    }
  } catch (error) {
    // File doesn't exist or is empty, that's okay
    console.log('AI Summary not available:', error);
  }
  return null;
}

const bioSections = await parseBioMarkdown();
const aiSummary = await loadAISummary();

// Add AI Summary at the end if available
if (aiSummary) {
  bioSections.push(aiSummary);
}

const defaultIndex = bioSections.findIndex(b => b.title.toLowerCase() === 'medium') >= 0 
  ? bioSections.findIndex(b => b.title.toLowerCase() === 'medium')
  : Math.floor(bioSections.length / 2);
---

<MainLayout title="About" description={pageDescription} ogImage={ogImage}>
  <div class="hero-image-container portrait-container">
    <HeroImageShader client:load src="/images/header-images/img-about.jpg" alt="David Hoang" />
    <h1>{pageTitle}</h1>
  </div>
  <div class="container">
    <div class="hero-grid">
      <div class="about-content">
        <div class="bio-controls glass-border">
          <div class="bio-slider-container">
            <div class="bio-slider-label-wrapper">
              <span class="bio-slider-current-label" id="bio-slider-current-label">{bioSections[defaultIndex]?.title || 'Medium'}</span>
            </div>
            <input 
              type="range" 
              id="bio-length-slider" 
              class="bio-slider" 
              min="0" 
              max={bioSections.length - 1} 
              value={defaultIndex} 
              step="0.01"
              aria-label="Select bio length"
              data-bio-count={bioSections.length}
            />
          </div>
        </div>
        
        <div class="bio-content-wrapper">
          {bioSections.map((bio, index) => (
            <div 
              class={`bio-content ${index === defaultIndex ? 'active' : ''}`}
              data-version={index}
              data-label={bio.title}
            >
              {bio.isAI && (
                <div class="ai-warning">
                  <span class="ai-warning-icon">⚠️</span>
                  <span class="ai-warning-text">AI generated, verify results</span>
                </div>
              )}
              <h2 class="bio-section-title">{bio.title}</h2>
              <div set:html={bio.content}></div>
            </div>
          ))}
        </div>
      </div>
    </div>
  </div>
  </div>
</MainLayout>

<style>

  .about-content {
    max-width: 800px;
    width: 100%;
  }

  .bio-controls {
    margin-bottom: 2rem;
    padding: 0.75rem 1rem;
    background: var(--color-sidebar-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    transition: background-color 0.4s var(--ease-inertia), border-color 0.4s var(--ease-inertia);
  }

  .bio-slider-container {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .bio-slider {
    width: 100%;
    height: 6px;
    border-radius: var(--radius-full, 9999px);
    background: var(--color-border);
    outline: none;
    -webkit-appearance: none;
    appearance: none;
    cursor: pointer;
    transition: background-color 0.4s var(--ease-inertia, ease);
    margin: 0.25rem 0;
  }

  .bio-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: var(--radius-full, 9999px);
    background: var(--color-text);
    border: 2px solid var(--color-bg);
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.4s ease, border-color 0.4s ease;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  }

  .bio-slider::-webkit-slider-thumb:hover {
    transform: scale(1.15);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  }

  .bio-slider:focus-visible::-webkit-slider-thumb {
    outline: 3px solid var(--color-link);
    outline-offset: 2px;
  }

  .bio-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: var(--radius-full, 9999px);
    background: var(--color-text);
    border: 2px solid var(--color-bg);
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.4s ease, border-color 0.4s ease;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  }

  .bio-slider::-moz-range-thumb:hover {
    transform: scale(1.15);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
  }

  .bio-slider:focus-visible::-moz-range-thumb {
    outline: 3px solid var(--color-link);
    outline-offset: 2px;
  }

  .bio-slider::-moz-range-track {
    height: 6px;
    border-radius: var(--radius-full, 9999px);
    background: var(--color-border);
    transition: background-color 0.4s ease;
  }

  .bio-slider-label-wrapper {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 0.25rem;
  }

  .bio-slider-current-label {
    font-size: 1rem;
    font-weight: var(--heading-weight, 600);
    color: var(--color-link);
    transition: color 0.4s ease, font-weight 0.4s ease;
    text-align: center;
  }

  .bio-content-wrapper {
    position: relative;
    min-height: 200px;
  }

  .bio-content {
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.4s var(--ease-inertia), transform 0.4s var(--ease-inertia);
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    pointer-events: none;
  }

  .bio-content.active {
    opacity: 1;
    transform: translateY(0);
    position: relative;
    pointer-events: auto;
  }

  .bio-section-title {
    font-size: 2rem;
    font-weight: 700;
    margin: 0 0 1.5rem 0;
    color: var(--color-text);
    line-height: 1.2;
  }

  .ai-warning {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    margin-bottom: 1rem;
    background: rgba(255, 193, 7, 0.1);
    border: 1px solid rgba(255, 193, 7, 0.3);
    border-radius: var(--radius-md);
    font-size: 0.875rem;
    color: var(--color-text);
  }

  .ai-warning-icon {
    font-size: 1rem;
    flex-shrink: 0;
  }

  .ai-warning-text {
    font-weight: 500;
  }

  [data-theme="dark"] .ai-warning {
    background: rgba(255, 193, 7, 0.15);
    border-color: rgba(255, 193, 7, 0.4);
  }

  
  /* Ensure images in content stay in container */
  .about-content img {
    max-width: 100%;
    height: auto;
  }

  @media (max-width: 768px) {
    .about-content {
      max-width: 100%;
    }

    .bio-controls {
      padding: 0.5rem 0.75rem;
    }

    .bio-slider-current-label {
      font-size: 0.9rem;
    }

    .bio-section-title {
      font-size: 1.75rem;
      margin-bottom: 1rem;
    }
  }

  @media (max-width: 480px) {
    .about-content {
      max-width: 100%;
    }
  }
</style>

<script>
  // Parallax scroll effect with smooth inertia-based animation
  function initParallax() {
    const imageContainer = document.querySelector('.hero-image-container') as HTMLElement | null;
    const image = document.querySelector('.hero-image-bg') as HTMLElement | null;

    if (!imageContainer || !image) return;

    let currentOffset = 0;
    let targetOffset = 0;
    let currentScale = 1;
    let targetScale = 1;
    let velocity = 0;
    let lastScrollY = window.scrollY;
    let lastTime = performance.now();
    let animationFrameId: number | null = null;
    let isScrolling = false;
    let scrollTimeout: number | null = null;

    // Smooth interpolation with inertia
    function lerp(start: number, end: number, factor: number) {
      return start + (end - start) * factor;
    }

    function calculateParallaxValues() {
      if (!imageContainer) return { offset: 0, scale: 1 };

      const rect = imageContainer.getBoundingClientRect();
      const windowHeight = window.innerHeight;
      const containerHeight = imageContainer.offsetHeight;
      const scrolled = window.scrollY;
      const containerTop = imageContainer.offsetTop;
      
      if (rect.bottom >= 0 && rect.top <= windowHeight) {
        const scrollDistance = scrolled - containerTop;
        const parallaxSpeed = 0.3;
        const offset = scrollDistance * parallaxSpeed;
        
        // Calculate scroll progress (0 to 1) within the container viewport
        // Scale from 1 to 1.2 as user scrolls down
        const scrollProgress = Math.max(0, Math.min(1, 
          (scrollDistance + windowHeight) / (containerHeight + windowHeight)
        ));
        const scale = 1 + (scrollProgress * 0.5); // 1 to 1.5
        
        return { offset, scale };
      } else if (rect.top > windowHeight) {
        return { offset: 0, scale: 1 };
      }
      return { offset: currentOffset, scale: currentScale };
    }

    function animate() {
      const now = performance.now();
      const deltaTime = Math.min((now - lastTime) / 1000, 0.1); // Cap at 100ms
      lastTime = now;

      // Calculate target offset and scale
      const { offset, scale } = calculateParallaxValues();
      targetOffset = offset;
      targetScale = scale;

      // Smooth interpolation with momentum
      const lerpFactor = isScrolling ? 0.15 : 0.08; // Faster when scrolling, slower when settling
      currentOffset = lerp(currentOffset, targetOffset, lerpFactor);
      currentScale = lerp(currentScale, targetScale, lerpFactor);

      // Apply velocity for inertia effect
      if (!isScrolling) {
        const difference = targetOffset - currentOffset;
        velocity = lerp(velocity, difference * 0.5, 0.1);
        currentOffset += velocity;
        
        // Damping - gradually reduce velocity
        velocity *= 0.92;
        
        // Stop animation when very close to target
        if (Math.abs(targetOffset - currentOffset) < 0.1 && Math.abs(velocity) < 0.1) {
          currentOffset = targetOffset;
          currentScale = targetScale;
          velocity = 0;
        }
      }

      // Apply transform with both translateY and scale
      if (image) {
        image.style.transform = `translateY(${currentOffset}px) scale(${currentScale})`;
      }

      // Continue animation if needed
      if (isScrolling || Math.abs(targetOffset - currentOffset) > 0.1 || Math.abs(targetScale - currentScale) > 0.001 || Math.abs(velocity) > 0.1) {
        animationFrameId = requestAnimationFrame(animate);
      } else {
        animationFrameId = null;
      }
    }

    function onScroll() {
      const currentScrollY = window.scrollY;
      const scrollDelta = currentScrollY - lastScrollY;
      lastScrollY = currentScrollY;

      // Mark as scrolling
      isScrolling = true;
      
      // Clear existing timeout
      if (scrollTimeout) {
        clearTimeout(scrollTimeout);
      }

      // Start animation if not already running
      if (!animationFrameId) {
        lastTime = performance.now();
        animationFrameId = requestAnimationFrame(animate);
      }

      // Detect when scrolling stops
      scrollTimeout = setTimeout(() => {
        isScrolling = false;
        // Continue animation for smooth deceleration
        if (!animationFrameId) {
          lastTime = performance.now();
          animationFrameId = requestAnimationFrame(animate);
        }
      }, 50) as unknown as number;
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    
    // Initial setup
    const initialValues = calculateParallaxValues();
    targetOffset = initialValues.offset;
    currentOffset = targetOffset;
    targetScale = initialValues.scale;
    currentScale = targetScale;
    lastTime = performance.now();
    animate();
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initParallax);
  } else {
    initParallax();
  }

  // Bio length slider functionality - smooth draggable spectrum
  function initBioSlider() {
    const slider = document.getElementById('bio-length-slider') as HTMLInputElement | null;
    const currentLabel = document.getElementById('bio-slider-current-label');
    const bioContents = document.querySelectorAll('.bio-content');

    if (!slider) return;

    // Get number of versions dynamically
    const numVersions = bioContents.length;
    const maxValue = numVersions - 1;
    
    // Extract labels from data attributes or use index as fallback
    const versionLabels: string[] = [];
    bioContents.forEach((content) => {
      const label = (content as HTMLElement).getAttribute('data-label') || 
                    (content as HTMLElement).getAttribute('data-version') || 
                    '';
      versionLabels.push(label);
    });

    // Update slider max if needed
    if (slider.max !== String(maxValue)) {
      slider.max = String(maxValue);
    }

    function getClosestVersion(value: number): number {
      // Snap to nearest version
      return Math.round(Math.max(0, Math.min(maxValue, value)));
    }

    function updateBioContent(value: number) {
      const version = getClosestVersion(value);
      const label = versionLabels[version] || `Version ${version + 1}`;

      // Update label
      if (currentLabel) {
        currentLabel.textContent = label;
      }

      // Update active content with smooth transitions
      bioContents.forEach((content) => {
        const bioContent = content as HTMLElement;
        const contentVersion = parseInt(bioContent.getAttribute('data-version') || '0');
        
        if (contentVersion === version) {
          bioContent.classList.add('active');
        } else {
          bioContent.classList.remove('active');
        }
      });
    }

    // Get initial value from slider
    const initialValue = parseFloat(slider.value) || Math.floor(numVersions / 2);
    updateBioContent(initialValue);

    // Handle slider input - smooth dragging
    slider.addEventListener('input', (e) => {
      const value = parseFloat((e.target as HTMLInputElement).value);
      updateBioContent(value);
    });

    // Snap to nearest position when user releases
    slider.addEventListener('change', (e) => {
      const value = parseFloat((e.target as HTMLInputElement).value);
      const snappedValue = getClosestVersion(value);
      slider.value = String(snappedValue);
      updateBioContent(snappedValue);
    });

    // Handle keyboard navigation
    slider.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        e.preventDefault();
        const currentValue = parseFloat(slider.value);
        const step = 0.25; // Smaller steps for smoother keyboard navigation
        
        if (e.key === 'ArrowLeft' && currentValue > 0) {
          const newValue = Math.max(0, currentValue - step);
          slider.value = String(newValue);
          updateBioContent(newValue);
        } else if (e.key === 'ArrowRight' && currentValue < maxValue) {
          const newValue = Math.min(maxValue, currentValue + step);
          slider.value = String(newValue);
          updateBioContent(newValue);
        }
      }
    });
  }

  // Initialize bio slider when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initBioSlider);
  } else {
    initBioSlider();
  }
</script>
